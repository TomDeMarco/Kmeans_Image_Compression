package cs1501_p5;

import java.util.Map;
import java.util.HashMap;
import java.util.Arrays;
import java.util.List;

public class ClusteringMapGenerator implements ColorMapGenerator_Inter {

    //instance variables
    private final DistanceMetric_Inter metric;

    //Constructor that allows choice of which distance metric to use
    public ClusteringMapGenerator(DistanceMetric_Inter chosenMetric){
        this.metric = chosenMetric;
    }

    /**
     * Produces an initial palette. This initial palette will be
     * the centers of the buckets and the starting centroids of clusters.
     * If numColors is greater than the number of unique colors in pixelArr,
     * this method should return a Pixel array containing all unique colors
     * in pixelArr. If numColors is less than 1, this method throws an
     * IllegalArgumentException.
     *
     * @param pixelArr  the 2D Pixel array that represents the bitmap image
     * @param numColors the number of desired colors in the palette
     * @return A Pixel array containing numColors elements
     * @throws java.lang.IllegalArgumentException if numColors is less than 1
     */
    public Pixel[] generateColorPalette(Pixel[][] pixelArr, int numColors) throws IllegalArgumentException{
        if(numColors < 1){
            throw new IllegalArgumentException();
        }
        Pixel[] pixels = new Pixel[numColors];

        //initialize first centroid as first pixel
        pixels[0] = pixelArr[0][0];

        //populate the rest of the array with the farthest possible pixel from the closest existing centroid
        for(int i = 1; i<numColors;i++){
            pixels[i] = findFarthestPixel(pixelArr,pixels);
        }
            return pixels;    
    }
    

   /**
    * Computes the reduced color map. For bucketing, this will map each color
    * to the center of its bucket, for clustering, this maps examples to final
    * centroids.
    *
    * @param pixelArr            the pixels array that represents the bitmap image
    * @param initialColorPalette an array of Pixels generated by generateColorPalette
    * @return A Map that maps each distinct color in pixelArr to a final color
    */
   public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArr, Pixel[] initialColorPalette){
    Map<Pixel, Pixel> colorMap = new HashMap<>();

    //initial assignment of pixels to their respective centroids
    Pixel[][] clusters = assignObservations(pixelArr, initialColorPalette);

    //4. Redo assignments/centroid calculation until convergence (I.e., no examples are assigned to new clusters after new centroids are computed)
    //Iterative update of centroids and reassignment untill convergence
        while (true) {
        Pixel[] updatedCentroids = updateCentroids(pixelArr,clusters,initialColorPalette);
        Pixel[][] newClusters = assignObservations(pixelArr, updatedCentroids);

        // Check for convergence by comparing new assignment with previous assignments
        if (Arrays.deepEquals(newClusters, clusters)) {
            break;
        }

        clusters = newClusters;
    }

    //Map each color in pixelArr to its value in the final color palatte
        for (int i = 0; i < pixelArr.length; i++) {
        for (int j = 0; j < pixelArr[i].length; j++) {
            Pixel pixel = pixelArr[i][j];
            Pixel finalColor = clusters[i][j];
            colorMap.put(pixel, finalColor);
        }
    }

    return colorMap;

   }

 // Helper Methods-----------------------------------------------
    // 3. For each cluster, compute the new centroid as the mean of all feature vectors in that cluster
    private Pixel[] updateCentroids(Pixel[][] pixelArr, Pixel[][] clusters, Pixel[] colorPalette) {
        
        //1d arrays to represent stats of each cluster
        int[] totalRed = new int[colorPalette.length];
        int[] totalGreen = new int[colorPalette.length];
        int[] totalBlue = new int[colorPalette.length];
        int[] clusterSize = new int[colorPalette.length];

        // Calculate total color values for each cluster
        for (int i = 0; i < pixelArr.length; i++) {
            for (int j = 0; j < pixelArr[i].length; j++) {
                Pixel pixel = pixelArr[i][j];
                Pixel clusterCentroid = findClosestCentroid(pixel, colorPalette);
                int clusterIndex = Arrays.asList(colorPalette).indexOf(clusterCentroid);

                totalRed[clusterIndex] += pixel.getRed();
                totalGreen[clusterIndex] += pixel.getGreen();
                totalBlue[clusterIndex] += pixel.getBlue();
                clusterSize[clusterIndex]++;
            }
        }

        // Calculate new centroids based on the mean color values
        Pixel[] updatedCentroids = new Pixel[colorPalette.length];
        for (int i = 0; i < colorPalette.length; i++) {
            int averageRed = totalRed[i] / clusterSize[i];
            int averageGreen = totalGreen[i] / clusterSize[i];
            int averageBlue = totalBlue[i] / clusterSize[i];
            updatedCentroids[i] = new Pixel(averageRed, averageGreen, averageBlue);
        }

        return updatedCentroids;
    }



   //2. Assign all observations to a centroid based on the smallest distance metric specified
    public Pixel[][] assignObservations(Pixel[][] pixelArr, Pixel[] initialColorPalette){
        Pixel[][] clusters = new Pixel[pixelArr.length][pixelArr[0].length];

        for(int i =0;i<pixelArr.length;i++){
            for(int j =0;j<pixelArr[i].length;j++){
                Pixel pix = pixelArr[i][j];
                Pixel ClosestCentroid = findClosestCentroid(pix,initialColorPalette);
                clusters[i][j]= ClosestCentroid;
            }
        }
        return clusters;
    }

    //find Farthest Pixel with the most significant color distance from its closest existing centroid
    public Pixel findFarthestPixel(Pixel[][] pixelArr, Pixel[] colorPalette){
        double maxDistance = 0;
        Pixel returnPixel = colorPalette[0];

        for(int i =0;i<pixelArr.length;i++){
            for(int j=0;j<pixelArr[0].length;j++){
                double distance = metric.colorDistance(pixelArr[i][j], findClosestCentroid(pixelArr[i][j],colorPalette ));
                //handle tie first, or change maxDistance and returnPixel
                if(distance == maxDistance){
                    if(pixelToInt(pixelArr[i][j])>pixelToInt(returnPixel)){
                        returnPixel=pixelArr[i][j];
                    }
                }else if(distance>maxDistance){
                        maxDistance=distance;
                        returnPixel=pixelArr[i][j];
                }
            }
        }
        return returnPixel;
    }

    //Should return the closest color in the ColorPallete(for clustering observations)
    public Pixel findClosestCentroid(Pixel thisPixel, Pixel[] colorPalette) {
    double minDistance = Double.MAX_VALUE;
    Pixel closestCentroid = colorPalette[0];

    for (int i =0;i<colorPalette.length;i++) {
        if (colorPalette[i] != null) {  // Null check
            double distance = metric.colorDistance(thisPixel, colorPalette[i]);
            if (distance < minDistance) {
                minDistance = distance;
                closestCentroid = colorPalette[i];
            }
        }
    }

    return closestCentroid;
}

            //Represent pixel as an int
          private int pixelToInt(Pixel pix) {
        return ((pix.getRed() << 16) & 0xff0000) | ((pix.getGreen() << 8) & 0xff00) | ((pix.getBlue() & 0xff));
    }
}
