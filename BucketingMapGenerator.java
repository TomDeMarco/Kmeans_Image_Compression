package cs1501_p5;
import java.util.Map;
import java.util.HashMap;

public class BucketingMapGenerator implements ColorMapGenerator_Inter { 
/**
     * Produces an initial palette. This initial palette will be
     * the centers of the buckets and the starting centroids of clusters.
     * If numColors is greater than the number of unique colors in pixelArr,
     * this method should return a Pixel array containing all unique colors
     * in pixelArr. If numColors is less than 1, this method throws an
     * IllegalArgumentException.
     *
     * @param pixelArr  the 2D Pixel array that represents the bitmap image
     * @param numColors the number of desired colors in the palette
     * @return A Pixel array containing numColors elements
     * @throws java.lang.IllegalArgumentException if numColors is less than 1
     */
    public Pixel[] generateColorPalette(Pixel[][] pixelArr, int numColors) throws IllegalArgumentException{
         if(numColors<1){
            throw new IllegalArgumentException();
         }else if(numColors ==1){

            Pixel[] pixels = new Pixel[1];
            pixels[0] = calculateAverageColor(pixelArr);
                     return pixels;

         }else{

            Pixel[] pixels = new Pixel[numColors];
            double bitSpace =  Math.pow(2,24);
            double bucketSize = bitSpace/numColors;
            for(int i=0;i<numColors;i++){
               int centerOfBucket = (int) (bucketSize*i + (bucketSize/2));
               int red = (centerOfBucket >> 16) & 0xFF;
               int green = (centerOfBucket >> 8) & 0xFF;
               int blue = centerOfBucket & 0xFF;
               pixels[i] = new Pixel(red,green,blue);
            }
                     return pixels;

         }
    }

   /**
    * Computes the reduced color map. For bucketing, this will map each color
    * to the center of its bucket, for clustering, this maps examples to final
    * centroids.
    *
    * @param pixelArr            the pixels array that represents the bitmap image
    * @param initialColorPalette an array of Pixels generated by generateColorPalette
    * @return A Map that maps each distinct color in pixelArr to a final color
    */
   public Map<Pixel, Pixel> generateColorMap(Pixel[][] pixelArr, Pixel[] initialColorPalette){

      Map<Pixel, Pixel> pixelMap = new HashMap<>();//hashmap for pixels


      for(int i = 0; i<pixelArr.length;i++){
         for(int j =0;j<pixelArr.length;j++){
            
            Pixel currPixel = pixelArr[i][j];
            Pixel mappedToPixel = findPixel(currPixel,initialColorPalette);
            pixelMap.put(currPixel,mappedToPixel);
         }
      }

      return pixelMap;

   }

   //Helper Methods--------------------------------------------------------------------------------------------------------------------------------------

   //Should return the closest color in the ColorPallete
   public Pixel findPixel(Pixel thisPixel, Pixel[] initialColorPalette){

      int thisPixelValue = pixelToInt(thisPixel);
      Pixel returnPixel = initialColorPalette[0];
      int bitSpace = (int) Math.pow(2,24)-1;
      int bucketSize= (int) bitSpace/initialColorPalette.length;
      int endOfBucket =0;
      
      for(int i=0;i<initialColorPalette.length;i++){
            endOfBucket = endOfBucket + bucketSize;
         if(pixelToInt(thisPixel)<=endOfBucket){
            returnPixel= initialColorPalette[i];
            break;     
         }
      
      }
              return returnPixel;
   }

   private int pixelToInt(Pixel pix) {
        return ((pix.getRed() << 16) & 0xff0000) | ((pix.getGreen() << 8) & 0xff00) | ((pix.getBlue() & 0xff));
   }

    // Helper method to calculate the average color of the entire image in instance of numColors = 1
   private Pixel calculateAverageColor(Pixel[][] pixelArr) {

            int bitSpace = (int) Math.pow(2,23);
               int red = (bitSpace >> 16) & 0xFF;
               int green = (bitSpace >> 8) & 0xFF;
               int blue = bitSpace & 0xFF;
               Pixel pixel = new Pixel(red,green,blue);
                     return pixel;
}

}


